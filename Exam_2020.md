# Eksamensoppgaver 2020

Sondre Lindaas Gjesdal

# Eksamen 2020 v4

## Oppgave 1

### Which of the following situations may lead to a loss of packets in a packet-switched network

1. A hosts informs a packet-switch that it decided not to transmit the packet anyway
2. Buffers overflow because too many packes arrive for transmission on a communication link
3. Interference of signals on a communication link causing some of the transmitted bits in the packet to be changed

**Correct:** 2. and 3.

### What is traffic intensity a measure of?

1. The amount of bits/second presented to a link for transmission
2. The amount of bits received on an incomring communication link
3. A relation between the amount of bits presented per time unit for transmission on the communication link and the rate with which the bits can be transmitted

**Correct:** 3.

### What does it mean that the transport layer provides a reliable data transfer service

1. The receiver may only receive some of the data sent by the sender
2. The data sent by a sender equals the data received by the receiver and the order is preserved
3. The data sent by a sender is equal to the data received by the receiver

**Correct:** 2.

### What is the role of the forwarding function executed at the network layer

1. To compute the least cost routes(paths) in the network
2. To transfer datagrams from incoming links to the appropriate outgoing link
3. To provide diagnostic information in case of network errors

**Correct:** 2.

### What is the purpose of the Address Resolution Protocol (ARP)

1. To configure a network interface with an IP address
2. To configure a network card with a link-layer(MAC) address
3. To map an IP address into the corresponding link-layer(MAC) address

**Correct:** 3.

### Client-centric consistency protocols are about

1. Making sure that there is a systemwide consistent view on a data store
2. Providing consistency for a single client that accesses different replicas
3. bot 1. and 2.

**Correct:** 2.

### A replicated-write protocol which is based on majority voting is called

1. Coherence-based protocol
2. Local-write protocol
3. Remote-write protocol
4. Quorum-based protocol

**Correct:** 4.

### A key reason to use a probabilistic flooding model in flooding-based multicasting is to

1. Create a structured overlay network
2. Increase the number of messages to ensure reliability
3. Reduce the number of messages in the network

**Correct:** 3.

### An example of location independent name is

1. An IP address
2. A domain name
3. A telephone number

**Correct:** 2.

### Which of the following is an example of cloud computing service models?

1. Business as a service
2. Software as a service
3. Utility as a service

**Correct:** 2.

## Oppgave 2

related to project 1 on socket programming and RPC middleware

### List the three protocol layers that were implemented in the project and explain briefly how they are related

IoT application layer, RPC layer and Messaging layer. The messaging layer was on top of TCP and was used to implement the RPC layer for remote-procedure calls. The RPC layer was then used byt the IoT application layer to implement the sensor-display-controller IoT system at the application layer

### The java socket API and the TCP transport service were used in the implementation. What two elements are being used to identify a socket (communication endpoint) at the transport layer of the TCP/IP protocol stack

A socket represents a communication endpoint and is identified using a port number and an IP address

### The messages exchanged in task 1 of the project has a fixed length of 128 bytes. Explain briefly the purpose of the first 8 bits in the messages and why they are needed

The first byte is interpreted as an int to tell how many of the subsequent 127 bytes is payload data. This is needed because the messages have a fixed length of 128 byte, leaving room for 127 bytes of data. But not all messages have 127 bytes of data.

### In task 2 of the project: When the server receives an RPC request from a client, how does the server identify the method to be invoked

The server side uses the identifier sent with the RPC request to look up the method to be invoked

**Correct:** The first byte of an RPC request message which is carried as a payload data in the fixed-size message at the messaging layer is used to specify the number of the RPC method. This number is then used to lookup the method in the RPC table on the RPC server.

**Correct but made correct:** The first byte in RPC request message which is carried as a payload data is used to specify the number of the RPC method.

### Sketch briefly how the message format in Task 1 of the project could be extended such that it would be possibly to arbitrarily long messages

The problem is similar to fragmentation with the exception that the individual parts cannot be reordered because messaging takes place over TCP. Hence, the first bit of the byte specifying payload length could be used to indicate whether this message is the last message of a longer message or not. This would leave 7 bits to specify payload length between 0 and 127.

## Oppgave 3

### Why are layering and protocol stacks used for implementation of data networks

Layering and protocol stacks are used to break up the complexity of data networks in smaller subproblems. This makes it possible to integrate different network technologies in a network-of-networks such that application can be developed without having to consider the complex internal structure of the data network. It also makes it possible to replace protocols at a given layer without having to make changes to the layer above or under.

### What is the difference between a protocol and a service

Protocol constitutes the rules that are implemented at a given layer in the protocol stack and governs the communication between entities at that layer. A protocol implements the service provided by the layer above to the layer above in the protocol stack. Protocol can be seen as implementing a service

### The TCP/IP protocol stack is used to construct a network of networks (the internet). All network cards have a link-layer (MAC) address and all network interfaces are configured with an IP network-layer address. Why are IP addresses used - would it not suffice to just use link-layer addresses

Link-Layer (MAC) addresses do not have any hierarchical structure as IP addresses have. Hence, use of link-layer addresses would not allow for route aggregation which is important for scalability of forwarding tables in the internet. Also, different link-layers may have different format of addresses which would prevent a uniform address space.

## Oppgave 4

### Explain briefly what service the DNS system implements, and the function of the fields: Flags, Questions and Answers

DNS system constitute a distributed database that makes it possible to map hostnames (e.g. google.com) to an IP address. In a typical scenario, Flags are used to indicate whether the message is a query or a reply message, Questions are to hold host names that are to be mapped to IP addresses, and answers will contain IP addresses

### Describe briefly how the DNS protocol works by outlining a typical exchange of messages between a DNS client adn a DNS server

The DNS protocol typically operates by the client sending a DNS query containing a host name to a DNS server. When the DNS server receives the query, then it may either iteratively or recursively contact other DNS servers until it eventually returns a DNS reply to the DNS client containing the IP address of the hostname that was to be resolved

### Assume that a DNS client has sent multiple DNS queries and receives a DNS reply. How can the client find out which DNS query that the DNS reply matches

The identification field of the DNS message is used to specify an identifier that can be used to match queries and replies

### The DNS primarily uses UDP as a transport service. Why is UDP and not TCP used to send DNS requests and replies

The DNS protocol typically involves a request and a reply after which the communication is completed. The overhead of establishing a TCP connection would therefore be relatively high compared to the amount of data that needs to be exchanged. In case a DNS client does not receive a reply because a DNS message was lost, the DNS client can simply retransmit the query

## Oppgave 5

### Least cost path from R2-R4

R2->R3->R4
1+2 = 3

### Show the steps performed by the loop part of the algorithm by adding a row to the above table for each iteration of the algorithm. Each row must specify the value of N', and the values of D(v) for each node v

|Step | N' | D(R1),p(R1) | D(R3),p(R3) | D(R4),p(R4)|
|:---: | :---: | :---: | :---: | :---: |
|0    |{R2}| 7,R2        | 1,R2        | 5,R4       |
|1(w=R3)|{R2,R3}|7,R2    | 1,R2        | 3,R3       |
|2(w=R4)|{R2,R3,R4}|7,R2 | 1,R2        | 3,R3       |
|3(w=R1)|{R2,R3,R4,R1}|7,R2| 1,R2      | 3,R3       |

### Show how the information computed in last task can be used to construct the forwarding table for R2. Each entry in the forwarding table must consist of a destination router and a next-hop router

For a given destination router we use the information provided by p(v) to find the least cost route back to R2

* Destination R4: p(R4) = R3 and p(R3) = R2, so next-hop from R2 is R3
* Destination R3: p(R3) = R2. Next hop is R3(direct)
* Destination R1: p(R1) = R2. Next hop is R1(direct)

## Oppgave 6
Consider the following IP network consisting of hosts H1-H6 and routers R1-R4. The integers 1,2 and 3 around R1 denote network interface identifiers. Link-layer and IP addresses are specified for some of the network interfaces of hosts and routers

### Assume that a new host H0 arrives at the local area network with H1 and H2. What protocol caan H0 use to automatically configure its network interface with an IP

Dynamic Host Configuration Protocol (DHCP) can be used to obtain an IP address

### Assume that host H0 obtained the IP address 132.200.1.4 and is to send a IP datagram to H5. As the first hop, the IP datagram needs to be sent in a frame from H0 to H1. What IP address should H0 specify in the ARP query that it sends in order to obtain the link-layer address of interface 1 of R1?

As the IP datagram is to be encapsulated into a frame and sent to interface 1 of R1 we need the link-layer address corresponding to 132.200.1.3.

### Assume that a IP datagram is sent from H0 via R1,R3,R4 to H5. How many times will the datagram be encapsulated into a frame on the route from H0 to H5 and how many times will it be decapsulated?

* The datagram will be encapsulated into a frame at H0, R1, R3, R4. 4 times in total.
* The datagram will be decapsulated from a frame at R1, R3,R4 and H5. 4 times here as well

### What 32-bit pattern does the IP address 221.198.1.5 corresponds to?

11011101.11000110.00000001.00000101

### Assume that the forwarding table of R1 contains the following entries

* 11011101 11000110 00000001 00000101
  * Next-hop interface: 2
* 11011101 11000110 00000001 00000110
  * Next-hop interface: 3
* Otherwise
  * Next-hop inteface: 1

### at which interface will router R1 forward datagrams with the following IP destination addresses

* 221.198.1.5 = 11011101 11000110 00000001 00000101 (interface 2)
* 221.198.1.6 = 11011101 11000110 00000001 00000110 (interface 3)

### Assume that the subnet containing hosts H5 and H6 has been given the address block 221.198.1/24. What interval of IP addresses does this block span

from 221.198.1.0 to 221.198.1.255

### How could the first two entries in the forwarding table be replaced with a single entry such that all datagrams for the network containing H5 and H6 will be sent via R2?

The addresses in the address block 221.198.1/24 can be described with the 24-bit address prefix: 221.198.1 = 11011101 11000110 00000001

As routing is based on longest prefix matching, we can replace the two entries with the entry:

* Destination = 11011101 11000110 00000001
* Next hop interface = 2

Using the address prefix 11011101.11000110.0000001.000001/30 or 11011101.11000110.00000001.00000/29 are also possible options since they make up the last two and three bits.

## Oppgave 7

The figure below shows the processes A, B and C that communicate using synchronous remote procedure call (RPC). A and B are clients, while C is a server. Use the figure to answer questions a and b

### Explain briefly how process B can be exchanged to an asynchronous RPC server

B wants to avoid blocking and be able to process many requests - i.e. a concurrent server. For that we need to use multithreading and (optionally) a client callback function registered on the server side. B can acknowledge the request to the client and hands-off the request from A or C to a new thread. When the request has been processed, the thread unblocks and trigger the callback function sending reply back to the client

### Explain briefly how process A and C can be changed to an asynchronous RPC client

The main concept here is that we do not want the clients A or C to block while waiting for the reply from B. Similar to a) we need to use multithreading and (optionally) callback functions from the client side. A can register a callback function with B, use/spawn a new thread each time a request is to be sent to the server (B) while the program continues on the main thread. B can send its reply to A using callback function

## Oppgave 8

Overlay network formed by processes A-E for multicasting messages. Process C is the root of the multicast tree and the path of the overlay network is C-B-A-D-E. The physical links are formed by five routers (Ra, Rb, Rc, Rd and Re). The numbers show the cost (delay) of sending messages across the physical links(routers)

### Compute the overlay network path and delay in the multicast tree when a message is multicast from

* C to E
  * C -> Rc -> Rb -> B -> Rb -> Ra -> A -> Ra -> Re -> Rd -> D -> Rd -> Re -> E
  * 1+40+1+1+25+1+1+100+30+1+1+30+1 = 233
* C to D
  * C -> Rc -> Rb -> B -> Rb -> Ra -> A -> Ra -> Re -> Rd -> D
  * 1+40+1+1+25+1+1+100+30+1 = 201

### Compute the stretch/relative delay penalty when a message is multicast from C to E provided that the best path (least cost) will be used by the underlying physical routers to route message from C to E

* Physical delay = 1+10+30+1 = 42
* RDP = 233/42 = 5.55

### Assume that the tree is modified such that path A -> D is removed and a new path A -> E is created resulting in new path beeing C -> B -> A -> E -> D. Compute the RDP to route message from C to E. Which tree is more efficient - original or modified. Explain in one sentence

* C -> Rc -> Rb -> B -> Rb -> Ra -> A -> Ra -> Re -> E
  * 1+40+1+1+25+1+1+100+1 = 171
* Physical
  * 1+10+30+1 = 42
* RDP
  * 171/42 = 4.07
  
Modified route is more effiecient. Cost to route a message is 4x the physical cost in the modified, compared to 5x in the original tree.

## Oppgave 9

MySQL uses lamport clocks to provide totally ordered messages in their five high availability server clusters represented by processes p1 - p5. Consider the following sequence of events at the 5 processes where Si and Ri are corresponding send and receive events for i=1-5 and the events (a-k) are concurrent events

* p1
  * a s1 r3 b
* p2
  * r1 s2 c s4
* p3
  * d r2 e s3 f
* p4
  * r4 g h s5 i
* p5
  * r5 j k

### Compute the lamport clock values for all the events at these five processes

Clock Ci = 0

1. Ci <- Ci + 1                             : send or local event
2. Cj <- max(m(c), Pi(j)). Then do rule 1   : receive event

* P1
  * a: 1
  * s1: 2
  * r3: 8
  * b: 9
* P2
  * r1: 3
  * s2: 4
  * c: 5
  * s4: 6
* P3
  * d: 1
  * r2: 5
  * e: 6
  * s3: 7
  * f: 8
* P4
  * r4: 7
  * g: 8
  * h: 9
  * s5: 10
  * i: 11
* P5
  * r5: 11
  * j: 12
  * k: 13

Essensielt så går vi bare gjennom alle prosessene, starter i de øverste prosessene som har ein event og fortsetter til man receiver. Då velger man største verdien (klokka i den prosessen eller fra receiving og tar + 1)

### Consider the following sequence of events at the 4 processes. Compute vector clock values for all the events at these four processes

* P1
  * a: [1, 0, 0, 0]
  * s1: [2, 0, 0, 0]
  * r3: [3, 2, 4, 0]
  * b: [4, 2, 4, 0]
* P2
  * r1: [2, 1, 0, 0]
  * s2: [2, 2, 0, 0]
  * c: [2, 3, 0, 0]
  * s4: [2, 4, 0, 0]
* P3
  * d: [0, 0, 1, 0]
  * r2: [2, 2, 2, 0]
  * e: [2, 2, 3, 0]
  * s3: [2, 2, 4, 0]
  * r5: [2, 4, 5, 4]
* P4
  * r4: [2, 4, 0, 1]
  * f: [2, 4, 0,2]
  * g: [2, 4, 0, 3]
  * s5: [2, 4, 0, 4]
  * h: [2, 4, 0, 5]

### What information does the vector clock [2, 4, 0, 1] at p4 give?

[2, 4, 0, 1] at p4 means that 2 events happened at p1, 4 at p2 at which p4 probably depends.(OR, p4 probably has a causal relationship to the 2 events in p1 and the 4 events in p2)

## Oppgave 10

Distributed hash tables.

A ring with m = 5 bit is used. Four server replicas (5,13,22,26) are organized in the ring. Each file is replicated 5 times and distributed in the replicas. Finger table for each server uses five entries computed as succ(n+2^(i-1)) where n is the node identifier and i is the finger table index

### What is the address size of the ring?

2^5 = 32{0,1,2,3,...,31}

### Compute the finger tables for each of the four server replicas (show computation steps)

if it goes over the length of the table, one takes ``value mod length``

Server = 5

* i = 1: succ(5+2^(1-1)) = Succ(6) = 13
* i = 2: succ(5+2^(2-1)) = Succ(7) = 13
* i = 3: succ(5+2^(3-1)) = Succ(9) = 13
* i = 4: succ(5+2^(4-1)) = Succ(13) = 13
* i = 5: succ(5+2^(5-1)) = Succ(21) = 22

Server = 13

* i = 1: succ(13+2^(1-1)) = Succ(14) = 22
* i = 2: succ(13+2^(2-1)) = Succ(15) = 22
* i = 3: succ(13+2^(3-1)) = Succ(17) = 22
* i = 4: succ(13+2^(4-1)) = Succ(21) = 22
* i = 5: succ(13+2^(5-1)) = Succ(29) = 5

Server = 22

* i = 1: succ(22+2^(1-1)) = Succ(23) = 26
* i = 2: succ(22+2^(2-1)) = Succ(24) = 26
* i = 3: succ(22+2^(3-1)) = Succ(26) = 26
* i = 4: succ(22+2^(4-1)) = Succ(30) = 5
* i = 5: succ(22+2^(5-1)) = Succ(38 mod 32) = Succ(6) = 13

Server = 26

* i = 1: succ(26+2^(1-1)) = Succ(27) = 5
* i = 2: succ(26+2^(2-1)) = Succ(28) = 5
* i = 3: succ(26+2^(3-1)) = Succ(30) = 5
* i = 4: succ(26+2^(4-1)) = Succ(34 mod 32) = Succ(2) = 5
* i = 5: succ(26+2^(5-1)) = Succ(42 mod 32) = Succ(10) = 13

### A music file f is replicated 5 times with keys = {0, 4, 15, 16, 24}. Which server replicas are responsible for the music file

Server >= key > pred(server) Or pred(server) < key <= server

* Server 5 is responsible for key = 0
* Server 5 is responsible for key = 4
* Server 22 is responsible for key 15
* Server 22 is responsible for key 16
* Server 26 is responsible for key 24

### Resolve the music file with key = 10 from server replica 26

Check if the server or its immediate successor is responsible/holding k (n < k <= succ(n)). If true, we have found the server, otherwise go to step 2

Go as farthest as possible from the current node to look for the closest predecessor to k. It means starting from the bottom of the finger table of our current server (n < Finger(5) < k). Repeat step 1

* Round 1
  * n=26, k=10
  * succ(26) = 5
  * Step 1: k between 26 and 5? No. Go to step 2 and find closes predecessor of k(i.e. 10)
  * Step 2: Is finger(5) = 13 between n and k? i.e. is 13 between 26 and 10? No,(continue next finger entry). Is finger(4) = 5 between 26 and 10? yes, return 5 as the current lookup node and goto step 1.
* Round 2
  * n=5, k=10
  * succ(5) = 13
  * Step 1: Is k between 5 and 13? Yes. Return 13 as the node responsible for key = 10.

The server holding key=10 is 13.

### Explain in one sentence how the above DHT setup partially provides fault tolerance

DHT setup provides bot data replication and process replication which are essential for fault tolerance

### Explain in one sentence how the above DHT setup provides size scalability

it is not a centralized system as load/data are distributed to several servers in the DHT and search/lookup is completed in O(logn)

### A music file f is replicated five times with keys {0, 4, 15, 16, 24} as in problem c. we want to avoid consistency problems when many clients attempt to update f at the same time

* Briefly explain how to implement a remote-write protocol to prevent a consistency problem
  * We can assign one of the servers (5, 22, or 26) as the primary for f. A client that wants to update needs to locate the primary server for f by first resolving for all the servers holding f (i.e. 5, 22, 26) and retrieving the primary among them. Once we know the primare, the update request can be forwarded to the primary. Primary will update and send update request to the remaining servers holding f.
* Explain in one sentence a disadvantage of using a remote-write protocol
  * main disadvantage is the communication overhead involved with locating the primary server responsible for the file in addition to blocking operations.

### We want to secure the communication among the 4 processes (5, 13, 22, 26) using public key cryptography(public/private keys). Use this information to answer the following two questions

* Explain how process 13 and process 22 can exchange encrypted communication
  * Process 13 can use the public key of process 22 to send encrypted messages to process 22 while process 22 uses its private key to decrypt the message. Similarly, process 22 can use the public key of process 13 to send encrypted message to process 13 while process 13 can decrypt the message with its private key
* Explain how process 5 can send a digitally signed message to process 26 and how process 26 can verify the signal from process 5
  * Process 5 will use its private key to sign a message(or digest a message) and send the message together with the signature to process 26. process 26 can verify the message using the public key of 5 to encrypt the message and then verify if the received signature from 5 is the same as the encrypted message

# Eksamen 2020 r4

## Oppgave 1 

### One reason to use multi-threading model in distributed environments is that

1. It makes redirection policy easier for the server
2. It is possible to process requests concurrently without blocking the entire process
3. It is less efficient to perform thread switch than process switch

**Correct:** 2

### A replicated-write protocol which is based on majority voting is called

1. Coherence-based protocol
2. Local-write protocol
3. Remote-write protocol
4. Quorom-based protocol

**Correct:** 4

### Given two events a and z, with lamport clocks C(a) and C(z) and their Vector clocks V(a) and V(z). What condition is necessary to conclude that event a happened before event z

1. a happened before z if C(a) < C(z)
2. a happened before z if V(a) < V(z)
3. a happened before z if C(a) > C(z)
4. a happened before z if V(a) > V(z)

**Correct:** 2

### A system is k-fault tolerant if

1. It can survive when k+1 processes failed
2. It can survive when all of its processes except k+1 processes failed
3. It can survive when k processes failed
4. It can survive when the majority of its processes failes

**Correct:** 3

### A major problem with reliable multicasting with feedback messages is:

1. Faulty processes
2. Ordering of multicast messages
3. Feedback explosion

**Correct:** 3.

### A distributed hash table with 8-bit identifier space will have a total address of

1. 512
2. 128
3. 256
4. Depends on the hash algorithm used

**Correct:** 2^8 = 256, 3

### A cloud service model where cloud providers rent out virtual machines to customers is known as

1. Software as a service
2. Platform as a service
3. Infrastructure as a service
4. Cloud as a service

**Correct:** 3. infrastructure as a service

### In digital signature

1. A secret key is used to both sign and verify a message
2. A public key is used to sign a message and the private key is used to verify the message
3. A private key is used to sign a message and the public key is used to verify the message

**Correct:** 3

## Oppgave 2

### Explain the difference between stateful and stateless servers

Stateful servers maintain persistent information about their clients while stateless do not keep information about the state of its client and can change its own state without having to inform its client

### Describe the difference between iterative and concurrent servers

Iterative server itself handles the request and, if necessary, returns a response to the requesting client while concurrent servers does the request itself, but passes it to a seperate thread or another process, after which it immediately waits for the next incoming request.

### Describe the difference between synchronous and asynchronous communication

In synchronous communication, the sender is blocked until its request is known to be accepted.

In asynchronous communication, sender continues immediately (not blocked) after it has submitted its message for transmission

## Oppgave 3

### Compute the overlay network path and delay in both multicast trees when a message is multicast from

#### A to C

* Tree a:
  * A -> Ra -> Rb -> B -> Rb -> Ra -> Re -> E -> Re -> Rc -> Rd -> D -> Rd -> Rc -> C
  * 1+7+1+1+7+30+1+1+20+5+1+1+5+1 = 82
* Tree b:
  * A -> Ra -> Re -> E -> Re -> Rc -> C
  * 1+30+1+1+20+1 = 54

#### B to D

* Tree a:
  * B -> Rb -> Ra -> Re -> E -> Re -> Rc -> Rd -> D
  * 1+7+30+1+1+20+5+1 = 66
* Tree b:
  * B -> Rb -> Ra -> A -> Ra -> Re -> E -> Re -> Rc -> C -> Rc -> Rd -> D
  * 1+7+1+1+30+1+1+20+1+1+5+1 = 70

#### E to C

* Tree a:
  * E -> Re -> Rc -> Rd -> D -> Rd -> Rc -> C
  * 1+20+5+1+1+5+1 = 34
* Tree b:
  * E -> Re -> Rc -> C
  * 1+20+1 = 22

#### B to C

* Tree a:
  * B -> Rb -> Ra -> Re -> E -> Re -> Rc -> Rd -> D -> Rd -> Rc -> C
  * 1+7+30+1+1+20+5+1+1+5+1 = 73
* Tree b:
  * B -> Rb -> Ra -> A -> Ra -> Re -> E -> Re -> Rc -> C
  * 1+7+1+1+30+1+1+20+1 = 53

### Use relative stretch/Relative Delay Penalty(RDP) metric to show which of the two trees is more efficient for multicasting messages. Explain your answer. The table below which also contains the physical link delays can be used to structure your answer

#### A -> C

* Tree a:
  * 82/52 = 1.57692
* Tree b
  * 54/52 = 1.03846

#### B -> D

* Tree a:
  * 66/42 = 1.57142
* Tree b:
  * 70/42 = 1.6666

#### E -> C

* Tree a:
  * 34/22 = 1.54545
* Tree b:
  * 22/22 = 1

#### B -> C

* Tree a:
  * 73/47 = 1.55
* Tree b:
  * 63/47 = 1.34

* Average tree a:
  * 1.57692 + 1.57142 + 1.54545 + 1.55 / 4 = 6.23421 / 4 = 1.56
* Average tree b:
  * 1.03846 + 1.6666 + 1 + 1.34 / 4 = 5.1 / 4 = 1.26

## Oppgave 4

### Explain how the distributed algorithm works for mutual exclusion in a distributed system and specify benefits and drawbacks

* When a process wants to access a shared resource it sends out its clock time to all other processes. To access a shared resource, a process wil build a message containing the name of the resource, its process numbre and the current (logical) time. It will then send the request to all other processes and wait until all the receiving processes have given permission. A process that receives the request message will decide to grant or deny permission using the following rules
  * Sends an OK message to the sender if its outside the critical section
  * If already in critical section, does not reply, but queues the request
  * If it receives a clock from another process it compares its own clock to the other. The lowest wins and will get an OK message from the highest.
  * If a process not interested in the resource receives a clock, it sends back an OK message.
* After the a process is finished in the critical section, it sends an OK message to all messages in queue, and deletes them from the queue.
* This requires total ordering of events and a lamport clock implemented in the system.
* **Benefits:**
  * Mutex is guaranteed without deadlock or starvation since everyone agrees on the ordering of the timestamps and conflict is resolved by using the process with the lower timestamp
  * Requires 2*(N-1) messages before a process can enter its critical region
* **Drawback**
  * Has N points of failure(crashes)
  * Each process must maintain the group membership list including entering, leaving and crashed processes
  * Works best with small groups of processes that never change group membership
* All processes are involved in all decisions concerning accessing the shared resource which can put burden on resource-constrained machines. In addition, any overloaded process can become a bottlenect

### Describe how the Local-write protocol works in a sequential consistency model

In a local write protocol, the primary copy migrates between processes that wish to perform a write operation. Whenever a process wants to update an item, it locates the primary copy of the item and moves it to its own location. The advantage is that multiple successive write operations can be carried out locally, while reading processes can still access their local copy. However, this can be achieved only if a non-blocking protocol is used while updates are then propagated to the replicas after the primary has finished

### Discuss briefly the five classes of failures that can occur in RPC systems

* The client cannot locate the server, so no request can be sent
* The clients request to the server is lost, so no response is returned by the server to the waiting client
* The server crashes after receiving the request, and the service request is left acknowledged, but undone
* The servers reply is lost on its way to the client, the service has completed, but the result never arrive at the client
* The client crashes after sending its request, ant the server sends a reply to a newly-restarted client that may not be expecting it

## Oppgave 5

### What is the address size of this ring?

2^3 = 8

### Compute the fingertables for each of the four server replicas

Server 0

* i = 1: Succ(0+2^(1-1)) = Succ(1) = 2
* i = 2: Succ(0+2^(2-1)) = Succ(2) = 2
* i = 3: Succ(0+2^(3-1)) = Succ(4) = 4

Server 2

* i = 1: Succ(2+2^(1-1)) = Succ(3) = 4
* i = 2: Succ(2+2^(2-1)) = Succ(4) = 4
* i = 3: Succ(2+2^(3-1)) = Succ(6) = 7

Server 4

* i = 1: Succ(4+2^(1-1)) = Succ(5) = 7
* i = 2: Succ(4+2^(2-1)) = Succ(6) = 7
* i = 3: Succ(4+2^(3-1)) = Succ(8 mod 8) = 0

Server 7

* i = 1: Succ(7+2^(1-1)) = Succ(8 mod 8) = 0
* i = 2: Succ(7+2^(2-1)) = Succ(9 mod 8) = 2
* i = 3: Succ(7+2^(3-1)) = Succ(11 mod 8) = 4

### A video is replicated 4 times with keys = {0,3,5}. Which server replicas are responsible for the video file?

Server >= key > pred(server)

* Server id = 0 is responsible for key = 0
* Server id = 4 is responsible for key = 3
* Server id = 7 is responsible for key = 5

### resolve the video file with key = 0 from server replica 2

* **Step 1:** Check if the server or its immediate successor is responsible/holding k (n< k <= succ(n)). If true, we have found the server, otherwise go to step 2
* **Step 2:** Go as farthest as possible from the current node to look for the closest predecessor to k. It means starting from the bottom of the finger table of our current server (n < Finger(3) < k). Repeat step 1

n = 2, k = 0

Succ(2) = 4

* Step 1: is k between 2 and 4), Nope, step 2 to find the closest predecessor of k
* Step 2: is finger(3) = 7 between n and k? is 7 between 2 and 0? yes. return 7 as the current lookup node and goto step 1

n = 7, k = 0, succ(7) = 0

* Step 1: is 0 between 7 and 0? Yes, return 0 as the node possible for key = 0

## Oppgave 6

### In the basic internet network model, where are applications residing?

1. At the network edge
2. In the access networks
3. In the network core

**Correct:** 1. at the network edge

### Transmission delay and propagation delay at a node(host or packet switch) are related?

1. True
2. False

**Correct:** 2. False

### A service provided by a protocol layer mandates the protocol that must be used to implement the service?

1. True
2. False

**Correct:** 2. false

### Which of the following alternative best describes the service provided by the TCP/IP network layer

1. Reliable point-to-point transmission of datagrams
2. Reliable bidirectional transmission of a stream of bytes
3. Unreliable multi-hop communication of datagrams between endpoints

**Correct:** 3

### What is the main purpose of the Socket API provided via the operating system

1. Makes it possible to implement shared memory communication between processes on the same machine
2. Makes it possible for application developers to access the TCP and UDP transport services
3. Makes it possible to access the DNS from within applications

**Correct:** 2.

### What is the main purpose of the DNS

1. Mapping of IP adresses to link-layer addresses(MAC)
2. Mapping of Universal Resource Identifiers to HTML webpages
3. Mapping of hostnames to IP addresses

**Correct:** 3.

### How are IP addresses used in the networking layer?

1. IP addresses are assigned to hosts and to routers
2. IP addresses are assigned to network interfaces of hosts and network interfaces of routers
3. IP addresses are assigned to only hosts

**Correct:** 2

### What is used to deliver the data contained in a transport segment to the correct socket?

1. Demultiplexing
2. Encapsulation
3. Multiplexing

**Correct:** 1. demultiplexing

## Oppgave 7

### What are the five levels that comprises the TCP/IP protocol stack

1. Application
2. Transport
3. Network
4. Link
5. Physical

### Specify for each of the following protocols the level of the TCP/IP protocol at which the protocol is implemented

1. DNS - Application layer
2. IP - Network
3. TCP - Transport
4. HTTP - Applicatoin layer

### Which TCP/IP layers are implemented by routers and which are implemented by hosts

* Router: Physical, Link, Network
* Hosts: All

## Oppgave 8

### Explain briefly what service the HTTP protocol provides and the function it fields

The method field specifies the type of the request such as GET(for retrieving an object/resource), PUT(for updating), POST(for creation) and DELETE(for deletion). The URL field specifies the identifies the requested object/resource.

### Describe briefly how the HTTP protocol works by outlining the typical exchange of messages between an HTTP client and an HTTP server

Typical exchange is that an HTTP client sends an HTTP request message to the server specifying the operation to be performed(via the method field) and the object/resource specified in the URL field. Based on this, the appropriate operation is performance at the server and a response is returned to the client in an HTTP response message.

### What is the advantage of using HTTP with persistent connections

The advantage is that the client avoids creating a new TCP connection for each HTTP request that is being sent to a given server. As the creation of a TCP connection takes time and consumes resources. The advantage is that the execution of the request between the client and a given HTTP server becomes more efficient

## Oppgave 9

### What 32-bit bit-pattern does the IP address 200.193.40.4 correspond to?

11001000 11000001 00101000 00000100

### Consider the CIDR (Class Internet Romain routing) address block 200.193.40.0/22. What interval of addresses does this block span?

200.193.40.0 to 200.193.43.255

## Oppgave 10

### Explain what information is stored in a switch table

The switch table maps MAC addresses into interface on the switch, i.e., keeps track of which interfaces lead to which MAC addresses

### Consider a local area network consisting of three hosts with IP and MAC addresses as specified in the figure and a switch with interfaces numbered 1-3 as specified in the figure. Assume that the ARP tables on all hosts are empty and that the switch-table on the switch is empty. What is the content of the ARP table on the host with IP address 192.168.0.1 after an IP datagram from 192.168.0.1 to 192.168.0.3 has been sent

The host with IP address 192.168.0.1 will have to obtain the MAC address of the host with IP 192.168.0.3 in order to send the IP datagram. This is one using the ARP protocol by sending and ARP query and receiving an ARP response. Based on this, it will update its ARP table to contain an entry mapping the IP 192.168.0.3 to the MAC address 49-BD-D2-C7.56-2A

### What will the content of the switch table be after an IP datagram from 192.168.0.1 to 192.168.0.3 has been sent

Upon completion a frame with source MAC address 1A-23-F9-CD-06-9B will have been sent into the switch on interface 3 (ARP query and also the IP datagram) and a fram (ARP response) with source MAC address 49-BD-D2-C7-56-2A will have been sent into the switch on interface 1. This means that the switch have learning the MAC address corresponding to interface 1 and 3 and hence have the following two entries in the switch tables:

1A-23-F9-CD-06-9B -> 3 and 49-BD-D2-C7-56-2A -> 1

# Eksamen 2019

## Oppgave 1

### One reason to use a multi-threading model in distributed environments is that

1. It makes redirection policy easier for the server
2. It is possible to the process requests concurrently without blocking the entire process
3. It is less efficient to perform thread switch than process switch

**Correct:** 2.

### Assume that the lamport clocks for events a, b and c are C(a) = 2, C(b) = 3 and C(c) = 3, respectfully. If events a and b happened in the same process, what can we conclude about the happens-before relationship between the events?

1. b and c happened at the same time
2. a -> c because C(a) < C(c)
3. C(a) < C(c) because a -> b

**Correct:** 3.

### Given two events a and z, with lamport clocks C(a) and C(z) and their vector clocks V(a) and V(z). What condition is necessary to conclude that event a happened before event z?

1. a happened before z if C(a) < C(z)
2. a happened before z if V(a) < V(z)
3. a happened before z if C(a) > C(z)
4. a happened before z if V(a) > V(z)

**Correct:** 2.

### The mutex algorithm where we could have N points of failure where N is the number of processes in the distributed system is

1. Decentralized
2. Distributed
3. Centralized
4. Token-ring

**Correct:** 2

### A general technique to provide process resilience in distributed systems is to

1. Organize several identical processes into a group
2. Forecast the fault so that systems can take action when the fault occurs
3. Use a fault-removal technique
4. Use a fault-prevention technique

**Correct:** 1

### How many processes are needed to form a byzantine agreement in a group with k faulty processes

1. 3k+1
2. 3k
3. k+1
4. 2k+1

**Correct:** 1.

### A cloud service model where vendors provide the users with the capability to develop and deploy applications in the cloud using the cloud service provided is known as

1. Software as a service
2. Platform as a service
3. Infrastructure as a service
4. Cloud as a service

**Correct:** 2 PaaS

### What security mechanism can we use to provide integrity and non-repudiation

1. Encryption
2. Digital signature and hashing
3. Message Authentication Code(MAC)

**Correct:** 2

## Oppgave 2

### What is the difference between stateful and stateless servers

A stateful server keeps persisten control of the state of its clients. While in a stateless server it does not have to inform its clients, and does not know the state of its clients.

### Describe the difference between iterative and concurrent servers

Both handles requests itself, but iterative replies to the requesting client, while concurrent sends the request on to another thread and starts to wait for the next requesting message

### Describe the difference between synchronous and asynchronous communication

Synchronous communication, the sender is blocked until it request is known to be accepted

Asynchronous communication, sender does not have to wait for its request to be accepted before carrying on

## Oppgave 3

###

## Oppgave 4

### Describe how the token-ring algorithm works for distributed mutual exclusion and specify benefits and drawbacks

A token is sent around a ring. The token is needed to access cs. If a process gets the token it uses it to enter the CS and then passes it to its neighbor. If it does not need to enter CS it simply passes it along.

**benefit**: Mutex is guaranteed and there is no starvation. Also only one process has the token at a given time

**drawbacks:** the token may be lost if a process crashes, message containing the token is lost. Crashed nodes can break the ring. If a neighbor crashes can also cause the token to be lost. Every process must maintain the current ring configuration

### Describe how the Remote-Write protocol works in a sequential consistency model

In a remote write protocol, all write operations must be forwarded to a single primary server that maintains this item. Read operations can be performed locally.

* All write operations are forwarded to the primary replica that maintains the item
* Primary performs the update on its local copy and forwards the update to backup servers
* Backup server performs the update and send acknowledgement to the primary
* Primary sends ack to initial process
* Read operations are carried out locally at each replica

Main challenge is communication overhead because replicas need to block during the update.

### Discuss the main problem of scalability in reliable group multicasting and discuss how non-hierarchical feedback control can be used to mitigate this problem

In reliable group multicasting, process or processes in a multicast group may not receive sent messages because the messages are lost. The issue then is how the sender become aware that a receiver does not receive its message. One approach is to use feedback control where a sender waits for acknowledgements from all receivers. Receiver keeps track of the last message from the sender in order to detect missing/lost messages from sender. In a very large process group the acknowledgements from all receivers can lead to what is called "feedback implosion".

Non-hierarchical feedback control uses acknowledgements for only missed messages (NACK) and aims to send only one NACK to the sender in the case where many receivers are missing the same message. Each receiver has a scheduled timer during which it waits to send a NACK. If a NACK for the same message is received from another receiver, the waiting receiver suppresses its own NACK message. The problem is that it is hard to correctly scheduler receiver's timer globally in a DS. Also, processes that received original messages correctly will have to process NACK that is useless to them.